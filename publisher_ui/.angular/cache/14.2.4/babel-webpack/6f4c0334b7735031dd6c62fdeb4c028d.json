{"ast":null,"code":"import { SelectionModel } from '@angular/cdk/collections';\nimport { FlatTreeControl } from '@angular/cdk/tree';\nimport { MatTreeFlatDataSource, MatTreeFlattener } from '@angular/material/tree';\nimport { BehaviorSubject } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/material/button\";\nimport * as i2 from \"@angular/material/checkbox\";\nimport * as i3 from \"@angular/material/icon\";\nimport * as i4 from \"@angular/material/form-field\";\nimport * as i5 from \"@angular/material/input\";\nimport * as i6 from \"@angular/material/tree\";\n\nfunction CatalogComponent_mat_tree_node_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r5 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"mat-tree-node\", 3);\n    i0.ɵɵelement(1, \"button\", 4);\n    i0.ɵɵelementStart(2, \"mat-checkbox\", 5);\n    i0.ɵɵlistener(\"change\", function CatalogComponent_mat_tree_node_1_Template_mat_checkbox_change_2_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r5);\n      const node_r3 = restoredCtx.$implicit;\n      const ctx_r4 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r4.todoLeafItemSelectionToggle(node_r3));\n    });\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const node_r3 = ctx.$implicit;\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"checked\", ctx_r0.checklistSelection.isSelected(node_r3));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(node_r3.item);\n  }\n}\n\nfunction CatalogComponent_mat_tree_node_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r9 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"mat-tree-node\", 6);\n    i0.ɵɵelement(1, \"button\", 4);\n    i0.ɵɵelementStart(2, \"mat-form-field\", 7)(3, \"mat-label\");\n    i0.ɵɵtext(4, \"New item...\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelement(5, \"input\", 8, 9);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(7, \"button\", 10);\n    i0.ɵɵlistener(\"click\", function CatalogComponent_mat_tree_node_2_Template_button_click_7_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r9);\n      const node_r6 = restoredCtx.$implicit;\n\n      const _r7 = i0.ɵɵreference(6);\n\n      const ctx_r8 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r8.saveNode(node_r6, _r7.value));\n    });\n    i0.ɵɵtext(8, \"Save\");\n    i0.ɵɵelementEnd()();\n  }\n}\n\nfunction CatalogComponent_mat_tree_node_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r12 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"mat-tree-node\", 6)(1, \"button\", 11)(2, \"mat-icon\", 12);\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementStart(4, \"mat-checkbox\", 13);\n    i0.ɵɵlistener(\"change\", function CatalogComponent_mat_tree_node_3_Template_mat_checkbox_change_4_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r12);\n      const node_r10 = restoredCtx.$implicit;\n      const ctx_r11 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r11.todoItemSelectionToggle(node_r10));\n    });\n    i0.ɵɵtext(5);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(6, \"button\", 14);\n    i0.ɵɵlistener(\"click\", function CatalogComponent_mat_tree_node_3_Template_button_click_6_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r12);\n      const node_r10 = restoredCtx.$implicit;\n      const ctx_r13 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r13.addNewItem(node_r10));\n    });\n    i0.ɵɵelementStart(7, \"mat-icon\");\n    i0.ɵɵtext(8, \"add\");\n    i0.ɵɵelementEnd()()();\n  }\n\n  if (rf & 2) {\n    const node_r10 = ctx.$implicit;\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵattribute(\"aria-label\", \"Toggle \" + node_r10.item);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r2.treeControl.isExpanded(node_r10) ? \"expand_more\" : \"chevron_right\", \" \");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"checked\", ctx_r2.descendantsAllSelected(node_r10))(\"indeterminate\", ctx_r2.descendantsPartiallySelected(node_r10));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(node_r10.item);\n  }\n}\n/**\r\n * Node for to-do item\r\n */\n\n\nexport class TodoItemNode {\n  constructor() {\n    this.children = [];\n  }\n\n}\n/** Flat to-do item node with expandable and level information */\n\nexport class TodoItemFlatNode {}\n/**\r\n * The Json object for to-do list data.\r\n */\n\nconst TREE_DATA = {\n  Groceries: {\n    'Almond Meal flour': null,\n    'Organic eggs': null,\n    'Protein Powder': null,\n    Fruits: {\n      Apple: null,\n      Berries: ['Blueberry', 'Raspberry'],\n      Orange: null\n    }\n  },\n  Reminders: ['Cook dinner', 'Read the Material Design spec', 'Upgrade Application to Angular']\n};\n/**\r\n * Checklist database, it can build a tree structured Json object.\r\n * Each node in Json object represents a to-do item or a category.\r\n * If a node is a category, it has children items and new items can be added under the category.\r\n */\n\nexport let ChecklistDatabase = /*#__PURE__*/(() => {\n  class ChecklistDatabase {\n    constructor() {\n      this.dataChange = new BehaviorSubject([]);\n      this.initialize();\n    }\n\n    get data() {\n      return this.dataChange.value;\n    }\n\n    initialize() {\n      // Build the tree nodes from Json object. The result is a list of `TodoItemNode` with nested\n      //     file node as children.\n      const data = this.buildFileTree(TREE_DATA, 0); // Notify the change.\n\n      this.dataChange.next(data);\n    }\n    /**\r\n     * Build the file structure tree. The `value` is the Json object, or a sub-tree of a Json object.\r\n     * The return value is the list of `TodoItemNode`.\r\n     */\n\n\n    buildFileTree(obj, level) {\n      return Object.keys(obj).reduce((accumulator, key) => {\n        const value = obj[key];\n        const node = new TodoItemNode();\n        node.item = key;\n\n        if (value != null) {\n          if (typeof value === 'object') {\n            node.children = this.buildFileTree(value, level + 1);\n          } else {\n            node.item = value;\n          }\n        }\n\n        return accumulator.concat(node);\n      }, []);\n    }\n    /** Add an item to to-do list */\n\n\n    insertItem(parent, name) {\n      if (parent.children) {\n        parent.children.push({\n          item: name\n        });\n        this.dataChange.next(this.data);\n      }\n    }\n\n    updateItem(node, name) {\n      node.item = name;\n      this.dataChange.next(this.data);\n    }\n\n  }\n\n  ChecklistDatabase.ɵfac = function ChecklistDatabase_Factory(t) {\n    return new (t || ChecklistDatabase)();\n  };\n\n  ChecklistDatabase.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: ChecklistDatabase,\n    factory: ChecklistDatabase.ɵfac\n  });\n  return ChecklistDatabase;\n})();\nexport let CatalogComponent = /*#__PURE__*/(() => {\n  class CatalogComponent {\n    constructor(_database) {\n      this._database = _database;\n      /** Map from flat node to nested node. This helps us finding the nested node to be modified */\n\n      this.flatNodeMap = new Map();\n      /** Map from nested node to flattened node. This helps us to keep the same object for selection */\n\n      this.nestedNodeMap = new Map();\n      /** A selected parent node to be inserted */\n\n      this.selectedParent = null;\n      /** The new item's name */\n\n      this.newItemName = '';\n      /** The selection for checklist */\n\n      this.checklistSelection = new SelectionModel(true\n      /* multiple */\n      );\n\n      this.getLevel = node => node.level;\n\n      this.isExpandable = node => node.expandable;\n\n      this.getChildren = node => node.children;\n\n      this.hasChild = (_, _nodeData) => _nodeData.expandable;\n\n      this.hasNoContent = (_, _nodeData) => _nodeData.item === '';\n      /**\r\n       * Transformer to convert nested node to flat node. Record the nodes in maps for later use.\r\n       */\n\n\n      this.transformer = (node, level) => {\n        const existingNode = this.nestedNodeMap.get(node);\n        const flatNode = existingNode && existingNode.item === node.item ? existingNode : new TodoItemFlatNode();\n        flatNode.item = node.item;\n        flatNode.level = level;\n        flatNode.expandable = !!node.children?.length;\n        this.flatNodeMap.set(flatNode, node);\n        this.nestedNodeMap.set(node, flatNode);\n        return flatNode;\n      };\n\n      this.treeFlattener = new MatTreeFlattener(this.transformer, this.getLevel, this.isExpandable, this.getChildren);\n      this.treeControl = new FlatTreeControl(this.getLevel, this.isExpandable);\n      this.dataSource = new MatTreeFlatDataSource(this.treeControl, this.treeFlattener);\n\n      _database.dataChange.subscribe(data => {\n        this.dataSource.data = data;\n      });\n    }\n    /** Whether all the descendants of the node are selected. */\n\n\n    descendantsAllSelected(node) {\n      const descendants = this.treeControl.getDescendants(node);\n      const descAllSelected = descendants.length > 0 && descendants.every(child => {\n        return this.checklistSelection.isSelected(child);\n      });\n      return descAllSelected;\n    }\n    /** Whether part of the descendants are selected */\n\n\n    descendantsPartiallySelected(node) {\n      const descendants = this.treeControl.getDescendants(node);\n      const result = descendants.some(child => this.checklistSelection.isSelected(child));\n      return result && !this.descendantsAllSelected(node);\n    }\n    /** Toggle the to-do item selection. Select/deselect all the descendants node */\n\n\n    todoItemSelectionToggle(node) {\n      this.checklistSelection.toggle(node);\n      const descendants = this.treeControl.getDescendants(node);\n      this.checklistSelection.isSelected(node) ? this.checklistSelection.select(...descendants) : this.checklistSelection.deselect(...descendants); // Force update for the parent\n\n      descendants.forEach(child => this.checklistSelection.isSelected(child));\n      this.checkAllParentsSelection(node);\n    }\n    /** Toggle a leaf to-do item selection. Check all the parents to see if they changed */\n\n\n    todoLeafItemSelectionToggle(node) {\n      this.checklistSelection.toggle(node);\n      this.checkAllParentsSelection(node);\n    }\n    /* Checks all the parents when a leaf node is selected/unselected */\n\n\n    checkAllParentsSelection(node) {\n      let parent = this.getParentNode(node);\n\n      while (parent) {\n        this.checkRootNodeSelection(parent);\n        parent = this.getParentNode(parent);\n      }\n    }\n    /** Check root node checked state and change it accordingly */\n\n\n    checkRootNodeSelection(node) {\n      const nodeSelected = this.checklistSelection.isSelected(node);\n      const descendants = this.treeControl.getDescendants(node);\n      const descAllSelected = descendants.length > 0 && descendants.every(child => {\n        return this.checklistSelection.isSelected(child);\n      });\n\n      if (nodeSelected && !descAllSelected) {\n        this.checklistSelection.deselect(node);\n      } else if (!nodeSelected && descAllSelected) {\n        this.checklistSelection.select(node);\n      }\n    }\n    /* Get the parent node of a node */\n\n\n    getParentNode(node) {\n      const currentLevel = this.getLevel(node);\n\n      if (currentLevel < 1) {\n        return null;\n      }\n\n      const startIndex = this.treeControl.dataNodes.indexOf(node) - 1;\n\n      for (let i = startIndex; i >= 0; i--) {\n        const currentNode = this.treeControl.dataNodes[i];\n\n        if (this.getLevel(currentNode) < currentLevel) {\n          return currentNode;\n        }\n      }\n\n      return null;\n    }\n    /** Select the category so we can insert the new item. */\n\n\n    addNewItem(node) {\n      const parentNode = this.flatNodeMap.get(node);\n\n      this._database.insertItem(parentNode, '');\n\n      this.treeControl.expand(node);\n    }\n    /** Save the node to database */\n\n\n    saveNode(node, itemValue) {\n      const nestedNode = this.flatNodeMap.get(node);\n\n      this._database.updateItem(nestedNode, itemValue);\n    }\n\n  }\n\n  CatalogComponent.ɵfac = function CatalogComponent_Factory(t) {\n    return new (t || CatalogComponent)(i0.ɵɵdirectiveInject(ChecklistDatabase));\n  };\n\n  CatalogComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: CatalogComponent,\n    selectors: [[\"app-catalog\"]],\n    features: [i0.ɵɵProvidersFeature([ChecklistDatabase])],\n    decls: 4,\n    vars: 4,\n    consts: [[3, \"dataSource\", \"treeControl\"], [\"matTreeNodeToggle\", \"\", \"matTreeNodePadding\", \"\", 4, \"matTreeNodeDef\"], [\"matTreeNodePadding\", \"\", 4, \"matTreeNodeDef\", \"matTreeNodeDefWhen\"], [\"matTreeNodeToggle\", \"\", \"matTreeNodePadding\", \"\"], [\"mat-icon-button\", \"\", \"disabled\", \"\"], [1, \"checklist-leaf-node\", 3, \"checked\", \"change\"], [\"matTreeNodePadding\", \"\"], [\"appearance\", \"fill\"], [\"matInput\", \"\", \"placeholder\", \"Ex. Lettuce\"], [\"itemValue\", \"\"], [\"mat-button\", \"\", 3, \"click\"], [\"mat-icon-button\", \"\", \"matTreeNodeToggle\", \"\"], [1, \"mat-icon-rtl-mirror\"], [3, \"checked\", \"indeterminate\", \"change\"], [\"mat-icon-button\", \"\", 3, \"click\"]],\n    template: function CatalogComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"mat-tree\", 0);\n        i0.ɵɵtemplate(1, CatalogComponent_mat_tree_node_1_Template, 4, 2, \"mat-tree-node\", 1);\n        i0.ɵɵtemplate(2, CatalogComponent_mat_tree_node_2_Template, 9, 0, \"mat-tree-node\", 2);\n        i0.ɵɵtemplate(3, CatalogComponent_mat_tree_node_3_Template, 9, 5, \"mat-tree-node\", 2);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"dataSource\", ctx.dataSource)(\"treeControl\", ctx.treeControl);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"matTreeNodeDefWhen\", ctx.hasNoContent);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"matTreeNodeDefWhen\", ctx.hasChild);\n      }\n    },\n    dependencies: [i1.MatButton, i2.MatCheckbox, i3.MatIcon, i4.MatFormField, i4.MatLabel, i5.MatInput, i6.MatTreeNodeDef, i6.MatTreeNodePadding, i6.MatTreeNodeToggle, i6.MatTree, i6.MatTreeNode],\n    styles: [\".mat-form-field[_ngcontent-%COMP%]{margin-right:4px}\"]\n  });\n  return CatalogComponent;\n})();","map":null,"metadata":{},"sourceType":"module"}