{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Directive, InjectionToken, Optional, SkipSelf, Inject, Injectable, inject, Injector, ViewContainerRef, EventEmitter, NgZone, ElementRef, InjectFlags, Input, Output, ContentChildren, NgModule } from '@angular/core';\nimport { Overlay, OverlayConfig, STANDARD_DROPDOWN_BELOW_POSITIONS, STANDARD_DROPDOWN_ADJACENT_POSITIONS, OverlayModule } from '@angular/cdk/overlay';\nimport { UP_ARROW, hasModifierKey, DOWN_ARROW, LEFT_ARROW, RIGHT_ARROW, ENTER, SPACE, TAB, ESCAPE } from '@angular/cdk/keycodes';\nimport { startWith, debounceTime, distinctUntilChanged, filter, takeUntil, mergeMap, mapTo, mergeAll, switchMap, skip } from 'rxjs/operators';\nimport { UniqueSelectionDispatcher } from '@angular/cdk/collections';\nimport { Subject, merge, fromEvent, defer, partition } from 'rxjs';\nimport { TemplatePortal } from '@angular/cdk/portal';\nimport { FocusKeyManager } from '@angular/cdk/a11y';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { Directionality } from '@angular/cdk/bidi';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * A grouping container for `CdkMenuItemRadio` instances, similar to a `role=\"radiogroup\"` element.\n */\n\nlet CdkMenuGroup = /*#__PURE__*/(() => {\n  class CdkMenuGroup {}\n\n  CdkMenuGroup.ɵfac = function CdkMenuGroup_Factory(t) {\n    return new (t || CdkMenuGroup)();\n  };\n\n  CdkMenuGroup.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CdkMenuGroup,\n    selectors: [[\"\", \"cdkMenuGroup\", \"\"]],\n    hostAttrs: [\"role\", \"group\", 1, \"cdk-menu-group\"],\n    exportAs: [\"cdkMenuGroup\"],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: UniqueSelectionDispatcher,\n      useClass: UniqueSelectionDispatcher\n    }])]\n  });\n  return CdkMenuGroup;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Injection token used to return classes implementing the Menu interface */\n\n\nconst CDK_MENU = /*#__PURE__*/new InjectionToken('cdk-menu');\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Injection token used for an implementation of MenuStack. */\n\nconst MENU_STACK = /*#__PURE__*/new InjectionToken('cdk-menu-stack');\n/** Provider that provides the parent menu stack, or a new menu stack if there is no parent one. */\n\nconst PARENT_OR_NEW_MENU_STACK_PROVIDER = {\n  provide: MENU_STACK,\n  deps: [[/*#__PURE__*/new Optional(), /*#__PURE__*/new SkipSelf(), /*#__PURE__*/new Inject(MENU_STACK)]],\n  useFactory: parentMenuStack => parentMenuStack || new MenuStack()\n};\n/** Provider that provides the parent menu stack, or a new inline menu stack if there is no parent one. */\n\nconst PARENT_OR_NEW_INLINE_MENU_STACK_PROVIDER = orientation => ({\n  provide: MENU_STACK,\n  deps: [[new Optional(), new SkipSelf(), new Inject(MENU_STACK)]],\n  useFactory: parentMenuStack => parentMenuStack || MenuStack.inline(orientation)\n});\n/** The next available menu stack ID. */\n\n\nlet nextId$2 = 0;\n/**\n * MenuStack allows subscribers to listen for close events (when a MenuStackItem is popped off\n * of the stack) in order to perform closing actions. Upon the MenuStack being empty it emits\n * from the `empty` observable specifying the next focus action which the listener should perform\n * as requested by the closer.\n */\n\nlet MenuStack = /*#__PURE__*/(() => {\n  class MenuStack {\n    constructor() {\n      /** The ID of this menu stack. */\n      this.id = `${nextId$2++}`;\n      /** All MenuStackItems tracked by this MenuStack. */\n\n      this._elements = [];\n      /** Emits the element which was popped off of the stack when requested by a closer. */\n\n      this._close = new Subject();\n      /** Emits once the MenuStack has become empty after popping off elements. */\n\n      this._empty = new Subject();\n      /** Emits whether any menu in the menu stack has focus. */\n\n      this._hasFocus = new Subject();\n      /** Observable which emits the MenuStackItem which has been requested to close. */\n\n      this.closed = this._close;\n      /** Observable which emits whether any menu in the menu stack has focus. */\n\n      this.hasFocus = this._hasFocus.pipe(startWith(false), debounceTime(0), distinctUntilChanged());\n      /**\n       * Observable which emits when the MenuStack is empty after popping off the last element. It\n       * emits a FocusNext event which specifies the action the closer has requested the listener\n       * perform.\n       */\n\n      this.emptied = this._empty;\n      /**\n       * Whether the inline menu associated with this menu stack is vertical or horizontal.\n       * `null` indicates there is no inline menu associated with this menu stack.\n       */\n\n      this._inlineMenuOrientation = null;\n    }\n    /** Creates a menu stack that originates from an inline menu. */\n\n\n    static inline(orientation) {\n      const stack = new MenuStack();\n      stack._inlineMenuOrientation = orientation;\n      return stack;\n    }\n    /**\n     * Adds an item to the menu stack.\n     * @param menu the MenuStackItem to put on the stack.\n     */\n\n\n    push(menu) {\n      this._elements.push(menu);\n    }\n    /**\n     * Pop items off of the stack up to and including `lastItem` and emit each on the close\n     * observable. If the stack is empty or `lastItem` is not on the stack it does nothing.\n     * @param lastItem the last item to pop off the stack.\n     * @param options Options that configure behavior on close.\n     */\n\n\n    close(lastItem, options) {\n      const {\n        focusNextOnEmpty,\n        focusParentTrigger\n      } = { ...options\n      };\n\n      if (this._elements.indexOf(lastItem) >= 0) {\n        let poppedElement;\n\n        do {\n          poppedElement = this._elements.pop();\n\n          this._close.next({\n            item: poppedElement,\n            focusParentTrigger\n          });\n        } while (poppedElement !== lastItem);\n\n        if (this.isEmpty()) {\n          this._empty.next(focusNextOnEmpty);\n        }\n      }\n    }\n    /**\n     * Pop items off of the stack up to but excluding `lastItem` and emit each on the close\n     * observable. If the stack is empty or `lastItem` is not on the stack it does nothing.\n     * @param lastItem the element which should be left on the stack\n     * @return whether or not an item was removed from the stack\n     */\n\n\n    closeSubMenuOf(lastItem) {\n      let removed = false;\n\n      if (this._elements.indexOf(lastItem) >= 0) {\n        removed = this.peek() !== lastItem;\n\n        while (this.peek() !== lastItem) {\n          this._close.next({\n            item: this._elements.pop()\n          });\n        }\n      }\n\n      return removed;\n    }\n    /**\n     * Pop off all MenuStackItems and emit each one on the `close` observable one by one.\n     * @param options Options that configure behavior on close.\n     */\n\n\n    closeAll(options) {\n      const {\n        focusNextOnEmpty,\n        focusParentTrigger\n      } = { ...options\n      };\n\n      if (!this.isEmpty()) {\n        while (!this.isEmpty()) {\n          const menuStackItem = this._elements.pop();\n\n          if (menuStackItem) {\n            this._close.next({\n              item: menuStackItem,\n              focusParentTrigger\n            });\n          }\n        }\n\n        this._empty.next(focusNextOnEmpty);\n      }\n    }\n    /** Return true if this stack is empty. */\n\n\n    isEmpty() {\n      return !this._elements.length;\n    }\n    /** Return the length of the stack. */\n\n\n    length() {\n      return this._elements.length;\n    }\n    /** Get the top most element on the stack. */\n\n\n    peek() {\n      return this._elements[this._elements.length - 1];\n    }\n    /** Whether the menu stack is associated with an inline menu. */\n\n\n    hasInlineMenu() {\n      return this._inlineMenuOrientation != null;\n    }\n    /** The orientation of the associated inline menu. */\n\n\n    inlineMenuOrientation() {\n      return this._inlineMenuOrientation;\n    }\n    /** Sets whether the menu stack contains the focused element. */\n\n\n    setHasFocus(hasFocus) {\n      this._hasFocus.next(hasFocus);\n    }\n\n  }\n\n  MenuStack.ɵfac = function MenuStack_Factory(t) {\n    return new (t || MenuStack)();\n  };\n\n  MenuStack.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: MenuStack,\n    factory: MenuStack.ɵfac\n  });\n  return MenuStack;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Injection token used for an implementation of MenuStack. */\n\n\nconst MENU_TRIGGER = /*#__PURE__*/new InjectionToken('cdk-menu-trigger');\n/**\n * Abstract directive that implements shared logic common to all menu triggers.\n * This class can be extended to create custom menu trigger types.\n */\n\nlet CdkMenuTriggerBase = /*#__PURE__*/(() => {\n  class CdkMenuTriggerBase {\n    constructor() {\n      /** The DI injector for this component. */\n      this.injector = inject(Injector);\n      /** The view container ref for this component */\n\n      this.viewContainerRef = inject(ViewContainerRef);\n      /** The menu stack in which this menu resides. */\n\n      this.menuStack = inject(MENU_STACK);\n      /** Emits when the attached menu is requested to open */\n\n      this.opened = new EventEmitter();\n      /** Emits when the attached menu is requested to close */\n\n      this.closed = new EventEmitter();\n      /** A reference to the overlay which manages the triggered menu */\n\n      this.overlayRef = null;\n      /** Emits when this trigger is destroyed. */\n\n      this.destroyed = new Subject();\n      /** Emits when the outside pointer events listener on the overlay should be stopped. */\n\n      this.stopOutsideClicksListener = merge(this.closed, this.destroyed);\n    }\n\n    ngOnDestroy() {\n      this._destroyOverlay();\n\n      this.destroyed.next();\n      this.destroyed.complete();\n    }\n    /** Whether the attached menu is open. */\n\n\n    isOpen() {\n      return !!this.overlayRef?.hasAttached();\n    }\n    /** Registers a child menu as having been opened by this trigger. */\n\n\n    registerChildMenu(child) {\n      this.childMenu = child;\n    }\n    /**\n     * Get the portal to be attached to the overlay which contains the menu. Allows for the menu\n     * content to change dynamically and be reflected in the application.\n     */\n\n\n    getMenuContentPortal() {\n      const hasMenuContentChanged = this.menuTemplateRef !== this._menuPortal?.templateRef;\n\n      if (this.menuTemplateRef && (!this._menuPortal || hasMenuContentChanged)) {\n        this._menuPortal = new TemplatePortal(this.menuTemplateRef, this.viewContainerRef, undefined, this._getChildMenuInjector());\n      }\n\n      return this._menuPortal;\n    }\n    /**\n     * Whether the given element is inside the scope of this trigger's menu stack.\n     * @param element The element to check.\n     * @return Whether the element is inside the scope of this trigger's menu stack.\n     */\n\n\n    isElementInsideMenuStack(element) {\n      for (let el = element; el; el = el?.parentElement ?? null) {\n        if (el.getAttribute('data-cdk-menu-stack-id') === this.menuStack.id) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n    /** Destroy and unset the overlay reference it if exists */\n\n\n    _destroyOverlay() {\n      if (this.overlayRef) {\n        this.overlayRef.dispose();\n        this.overlayRef = null;\n      }\n    }\n    /** Gets the injector to use when creating a child menu. */\n\n\n    _getChildMenuInjector() {\n      this._childMenuInjector = this._childMenuInjector || Injector.create({\n        providers: [{\n          provide: MENU_TRIGGER,\n          useValue: this\n        }, {\n          provide: MENU_STACK,\n          useValue: this.menuStack\n        }],\n        parent: this.injector\n      });\n      return this._childMenuInjector;\n    }\n\n  }\n\n  CdkMenuTriggerBase.ɵfac = function CdkMenuTriggerBase_Factory(t) {\n    return new (t || CdkMenuTriggerBase)();\n  };\n\n  CdkMenuTriggerBase.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CdkMenuTriggerBase,\n    hostVars: 2,\n    hostBindings: function CdkMenuTriggerBase_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-controls\", ctx.childMenu == null ? null : ctx.childMenu.id)(\"data-cdk-menu-stack-id\", ctx.menuStack.id);\n      }\n    }\n  });\n  return CdkMenuTriggerBase;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Throws an exception when an instance of the PointerFocusTracker is not provided.\n * @docs-private\n */\n\n\nfunction throwMissingPointerFocusTracker() {\n  throw Error('expected an instance of PointerFocusTracker to be provided');\n}\n/**\n * Throws an exception when a reference to the parent menu is not provided.\n * @docs-private\n */\n\n\nfunction throwMissingMenuReference() {\n  throw Error('expected a reference to the parent menu');\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Injection token used for an implementation of MenuAim. */\n\n\nconst MENU_AIM = /*#__PURE__*/new InjectionToken('cdk-menu-aim');\n/** Capture every nth mouse move event. */\n\nconst MOUSE_MOVE_SAMPLE_FREQUENCY = 3;\n/** The number of mouse move events to track. */\n\nconst NUM_POINTS = 5;\n/**\n * How long to wait before closing a sibling menu if a user stops short of the submenu they were\n * predicted to go into.\n */\n\nconst CLOSE_DELAY = 300;\n/** Calculate the slope between point a and b. */\n\nfunction getSlope(a, b) {\n  return (b.y - a.y) / (b.x - a.x);\n}\n/** Calculate the y intercept for the given point and slope. */\n\n\nfunction getYIntercept(point, slope) {\n  return point.y - slope * point.x;\n}\n/**\n * Whether the given mouse trajectory line defined by the slope and y intercept falls within the\n * submenu as defined by `submenuPoints`\n * @param submenuPoints the submenu DOMRect points.\n * @param m the slope of the trajectory line.\n * @param b the y intercept of the trajectory line.\n * @return true if any point on the line falls within the submenu.\n */\n\n\nfunction isWithinSubmenu(submenuPoints, m, b) {\n  const {\n    left,\n    right,\n    top,\n    bottom\n  } = submenuPoints; // Check for intersection with each edge of the submenu (left, right, top, bottom)\n  // by fixing one coordinate to that edge's coordinate (either x or y) and checking if the\n  // other coordinate is within bounds.\n\n  return m * left + b >= top && m * left + b <= bottom || m * right + b >= top && m * right + b <= bottom || (top - b) / m >= left && (top - b) / m <= right || (bottom - b) / m >= left && (bottom - b) / m <= right;\n}\n/**\n * TargetMenuAim predicts if a user is moving into a submenu. It calculates the\n * trajectory of the user's mouse movement in the current menu to determine if the\n * mouse is moving towards an open submenu.\n *\n * The determination is made by calculating the slope of the users last NUM_POINTS moves where each\n * pair of points determines if the trajectory line points into the submenu. It uses consensus\n * approach by checking if at least NUM_POINTS / 2 pairs determine that the user is moving towards\n * to submenu.\n */\n\n\nlet TargetMenuAim = /*#__PURE__*/(() => {\n  class TargetMenuAim {\n    constructor() {\n      /** The Angular zone. */\n      this._ngZone = inject(NgZone);\n      /** The last NUM_POINTS mouse move events. */\n\n      this._points = [];\n      /** Emits when this service is destroyed. */\n\n      this._destroyed = new Subject();\n    }\n\n    ngOnDestroy() {\n      this._destroyed.next();\n\n      this._destroyed.complete();\n    }\n    /**\n     * Set the Menu and its PointerFocusTracker.\n     * @param menu The menu that this menu aim service controls.\n     * @param pointerTracker The `PointerFocusTracker` for the given menu.\n     */\n\n\n    initialize(menu, pointerTracker) {\n      this._menu = menu;\n      this._pointerTracker = pointerTracker;\n\n      this._subscribeToMouseMoves();\n    }\n    /**\n     * Calls the `doToggle` callback when it is deemed that the user is not moving towards\n     * the submenu.\n     * @param doToggle the function called when the user is not moving towards the submenu.\n     */\n\n\n    toggle(doToggle) {\n      // If the menu is horizontal the sub-menus open below and there is no risk of premature\n      // closing of any sub-menus therefore we automatically resolve the callback.\n      if (this._menu.orientation === 'horizontal') {\n        doToggle();\n      }\n\n      this._checkConfigured();\n\n      const siblingItemIsWaiting = !!this._timeoutId;\n      const hasPoints = this._points.length > 1;\n\n      if (hasPoints && !siblingItemIsWaiting) {\n        if (this._isMovingToSubmenu()) {\n          this._startTimeout(doToggle);\n        } else {\n          doToggle();\n        }\n      } else if (!siblingItemIsWaiting) {\n        doToggle();\n      }\n    }\n    /**\n     * Start the delayed toggle handler if one isn't running already.\n     *\n     * The delayed toggle handler executes the `doToggle` callback after some period of time iff the\n     * users mouse is on an item in the current menu.\n     *\n     * @param doToggle the function called when the user is not moving towards the submenu.\n     */\n\n\n    _startTimeout(doToggle) {\n      // If the users mouse is moving towards a submenu we don't want to immediately resolve.\n      // Wait for some period of time before determining if the previous menu should close in\n      // cases where the user may have moved towards the submenu but stopped on a sibling menu\n      // item intentionally.\n      const timeoutId = setTimeout(() => {\n        // Resolve if the user is currently moused over some element in the root menu\n        if (this._pointerTracker.activeElement && timeoutId === this._timeoutId) {\n          doToggle();\n        }\n\n        this._timeoutId = null;\n      }, CLOSE_DELAY);\n      this._timeoutId = timeoutId;\n    }\n    /** Whether the user is heading towards the open submenu. */\n\n\n    _isMovingToSubmenu() {\n      const submenuPoints = this._getSubmenuBounds();\n\n      if (!submenuPoints) {\n        return false;\n      }\n\n      let numMoving = 0;\n      const currPoint = this._points[this._points.length - 1]; // start from the second last point and calculate the slope between each point and the last\n      // point.\n\n      for (let i = this._points.length - 2; i >= 0; i--) {\n        const previous = this._points[i];\n        const slope = getSlope(currPoint, previous);\n\n        if (isWithinSubmenu(submenuPoints, slope, getYIntercept(currPoint, slope))) {\n          numMoving++;\n        }\n      }\n\n      return numMoving >= Math.floor(NUM_POINTS / 2);\n    }\n    /** Get the bounding DOMRect for the open submenu. */\n\n\n    _getSubmenuBounds() {\n      return this._pointerTracker?.previousElement?.getMenu()?.nativeElement.getBoundingClientRect();\n    }\n    /**\n     * Check if a reference to the PointerFocusTracker and menu element is provided.\n     * @throws an error if neither reference is provided.\n     */\n\n\n    _checkConfigured() {\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        if (!this._pointerTracker) {\n          throwMissingPointerFocusTracker();\n        }\n\n        if (!this._menu) {\n          throwMissingMenuReference();\n        }\n      }\n    }\n    /** Subscribe to the root menus mouse move events and update the tracked mouse points. */\n\n\n    _subscribeToMouseMoves() {\n      this._ngZone.runOutsideAngular(() => {\n        fromEvent(this._menu.nativeElement, 'mousemove').pipe(filter((_, index) => index % MOUSE_MOVE_SAMPLE_FREQUENCY === 0), takeUntil(this._destroyed)).subscribe(event => {\n          this._points.push({\n            x: event.clientX,\n            y: event.clientY\n          });\n\n          if (this._points.length > NUM_POINTS) {\n            this._points.shift();\n          }\n        });\n      });\n    }\n\n  }\n\n  TargetMenuAim.ɵfac = function TargetMenuAim_Factory(t) {\n    return new (t || TargetMenuAim)();\n  };\n\n  TargetMenuAim.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: TargetMenuAim,\n    factory: TargetMenuAim.ɵfac\n  });\n  return TargetMenuAim;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * CdkTargetMenuAim is a provider for the TargetMenuAim service. It can be added to an\n * element with either the `cdkMenu` or `cdkMenuBar` directive and child menu items.\n */\n\n\nlet CdkTargetMenuAim = /*#__PURE__*/(() => {\n  class CdkTargetMenuAim {}\n\n  CdkTargetMenuAim.ɵfac = function CdkTargetMenuAim_Factory(t) {\n    return new (t || CdkTargetMenuAim)();\n  };\n\n  CdkTargetMenuAim.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CdkTargetMenuAim,\n    selectors: [[\"\", \"cdkTargetMenuAim\", \"\"]],\n    exportAs: [\"cdkTargetMenuAim\"],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: MENU_AIM,\n      useClass: TargetMenuAim\n    }])]\n  });\n  return CdkTargetMenuAim;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * A directive that turns its host element into a trigger for a popup menu.\n * It can be combined with cdkMenuItem to create sub-menus. If the element is in a top level\n * MenuBar it will open the menu on click, or if a sibling is already opened it will open on hover.\n * If it is inside of a Menu it will open the attached Submenu on hover regardless of its sibling\n * state.\n */\n\n\nlet CdkMenuTrigger = /*#__PURE__*/(() => {\n  class CdkMenuTrigger extends CdkMenuTriggerBase {\n    constructor() {\n      super();\n      /** The host element. */\n\n      this._elementRef = inject(ElementRef);\n      /** The CDK overlay service. */\n\n      this._overlay = inject(Overlay);\n      /** The Angular zone. */\n\n      this._ngZone = inject(NgZone);\n      /** The parent menu this trigger belongs to. */\n\n      this._parentMenu = inject(CDK_MENU, InjectFlags.Optional);\n      /** The menu aim service used by this menu. */\n\n      this._menuAim = inject(MENU_AIM, InjectFlags.Optional);\n      /** The directionality of the page. */\n\n      this._directionality = inject(Directionality, InjectFlags.Optional);\n\n      this._setRole();\n\n      this._registerCloseHandler();\n\n      this._subscribeToMenuStackClosed();\n\n      this._subscribeToMouseEnter();\n\n      this._subscribeToMenuStackHasFocus();\n\n      this._setType();\n    }\n    /** Toggle the attached menu. */\n\n\n    toggle() {\n      this.isOpen() ? this.close() : this.open();\n    }\n    /** Open the attached menu. */\n\n\n    open() {\n      if (!this.isOpen()) {\n        this.opened.next();\n        this.overlayRef = this.overlayRef || this._overlay.create(this._getOverlayConfig());\n        this.overlayRef.attach(this.getMenuContentPortal());\n\n        this._subscribeToOutsideClicks();\n      }\n    }\n    /** Close the opened menu. */\n\n\n    close() {\n      if (this.isOpen()) {\n        this.closed.next();\n        this.overlayRef.detach();\n      }\n\n      this._closeSiblingTriggers();\n    }\n    /**\n     * Get a reference to the rendered Menu if the Menu is open and rendered in the DOM.\n     */\n\n\n    getMenu() {\n      return this.childMenu;\n    }\n    /**\n     * Handles keyboard events for the menu item.\n     * @param event The keyboard event to handle\n     */\n\n\n    _toggleOnKeydown(event) {\n      const isParentVertical = this._parentMenu?.orientation === 'vertical';\n      const keyCode = event.keyCode;\n\n      switch (keyCode) {\n        case SPACE:\n        case ENTER:\n          if (!hasModifierKey(event)) {\n            this.toggle();\n            this.childMenu?.focusFirstItem('keyboard');\n          }\n\n          break;\n\n        case RIGHT_ARROW:\n          if (!hasModifierKey(event)) {\n            if (this._parentMenu && isParentVertical && this._directionality?.value !== 'rtl') {\n              event.preventDefault();\n              this.open();\n              this.childMenu?.focusFirstItem('keyboard');\n            }\n          }\n\n          break;\n\n        case LEFT_ARROW:\n          if (!hasModifierKey(event)) {\n            if (this._parentMenu && isParentVertical && this._directionality?.value === 'rtl') {\n              event.preventDefault();\n              this.open();\n              this.childMenu?.focusFirstItem('keyboard');\n            }\n          }\n\n          break;\n\n        case DOWN_ARROW:\n        case UP_ARROW:\n          if (!hasModifierKey(event)) {\n            if (!isParentVertical) {\n              event.preventDefault();\n              this.open();\n              keyCode === DOWN_ARROW ? this.childMenu?.focusFirstItem('keyboard') : this.childMenu?.focusLastItem('keyboard');\n            }\n          }\n\n          break;\n      }\n    }\n    /**\n     * Sets whether the trigger's menu stack has focus.\n     * @param hasFocus Whether the menu stack has focus.\n     */\n\n\n    _setHasFocus(hasFocus) {\n      if (!this._parentMenu) {\n        this.menuStack.setHasFocus(hasFocus);\n      }\n    }\n    /**\n     * Subscribe to the mouseenter events and close any sibling menu items if this element is moused\n     * into.\n     */\n\n\n    _subscribeToMouseEnter() {\n      // Closes any sibling menu items and opens the menu associated with this trigger.\n      const toggleMenus = () => this._ngZone.run(() => {\n        this._closeSiblingTriggers();\n\n        this.open();\n      });\n\n      this._ngZone.runOutsideAngular(() => {\n        fromEvent(this._elementRef.nativeElement, 'mouseenter').pipe(filter(() => !this.menuStack.isEmpty() && !this.isOpen()), takeUntil(this.destroyed)).subscribe(() => {\n          if (this._menuAim) {\n            this._menuAim.toggle(toggleMenus);\n          } else {\n            toggleMenus();\n          }\n        });\n      });\n    }\n    /** Close out any sibling menu trigger menus. */\n\n\n    _closeSiblingTriggers() {\n      if (this._parentMenu) {\n        // If nothing was removed from the stack and the last element is not the parent item\n        // that means that the parent menu is a menu bar since we don't put the menu bar on the\n        // stack\n        const isParentMenuBar = !this.menuStack.closeSubMenuOf(this._parentMenu) && this.menuStack.peek() !== this._parentMenu;\n\n        if (isParentMenuBar) {\n          this.menuStack.closeAll();\n        }\n      } else {\n        this.menuStack.closeAll();\n      }\n    }\n    /** Get the configuration object used to create the overlay. */\n\n\n    _getOverlayConfig() {\n      return new OverlayConfig({\n        positionStrategy: this._getOverlayPositionStrategy(),\n        scrollStrategy: this._overlay.scrollStrategies.reposition(),\n        direction: this._directionality || undefined\n      });\n    }\n    /** Build the position strategy for the overlay which specifies where to place the menu. */\n\n\n    _getOverlayPositionStrategy() {\n      return this._overlay.position().flexibleConnectedTo(this._elementRef).withLockedPosition().withGrowAfterOpen().withPositions(this._getOverlayPositions());\n    }\n    /** Get the preferred positions for the opened menu relative to the menu item. */\n\n\n    _getOverlayPositions() {\n      return this.menuPosition ?? (!this._parentMenu || this._parentMenu.orientation === 'horizontal' ? STANDARD_DROPDOWN_BELOW_POSITIONS : STANDARD_DROPDOWN_ADJACENT_POSITIONS);\n    }\n    /**\n     * Subscribe to the MenuStack close events if this is a standalone trigger and close out the menu\n     * this triggers when requested.\n     */\n\n\n    _registerCloseHandler() {\n      if (!this._parentMenu) {\n        this.menuStack.closed.pipe(takeUntil(this.destroyed)).subscribe(({\n          item\n        }) => {\n          if (item === this.childMenu) {\n            this.close();\n          }\n        });\n      }\n    }\n    /**\n     * Subscribe to the overlays outside pointer events stream and handle closing out the stack if a\n     * click occurs outside the menus.\n     */\n\n\n    _subscribeToOutsideClicks() {\n      if (this.overlayRef) {\n        this.overlayRef.outsidePointerEvents().pipe(filter(e => e.target != this._elementRef.nativeElement && !this._elementRef.nativeElement.contains(e.target)), takeUntil(this.stopOutsideClicksListener)).subscribe(event => {\n          if (!this.isElementInsideMenuStack(event.target)) {\n            this.menuStack.closeAll();\n          } else {\n            this._closeSiblingTriggers();\n          }\n        });\n      }\n    }\n    /** Subscribe to the MenuStack hasFocus events. */\n\n\n    _subscribeToMenuStackHasFocus() {\n      if (!this._parentMenu) {\n        this.menuStack.hasFocus.pipe(takeUntil(this.destroyed)).subscribe(hasFocus => {\n          if (!hasFocus) {\n            this.menuStack.closeAll();\n          }\n        });\n      }\n    }\n    /** Subscribe to the MenuStack closed events. */\n\n\n    _subscribeToMenuStackClosed() {\n      if (!this._parentMenu) {\n        this.menuStack.closed.subscribe(({\n          focusParentTrigger\n        }) => {\n          if (focusParentTrigger && !this.menuStack.length()) {\n            this._elementRef.nativeElement.focus();\n          }\n        });\n      }\n    }\n    /** Sets the role attribute for this trigger if needed. */\n\n\n    _setRole() {\n      // If this trigger is part of another menu, the cdkMenuItem directive will handle setting the\n      // role, otherwise this is a standalone trigger, and we should ensure it has role=\"button\".\n      if (!this._parentMenu) {\n        this._elementRef.nativeElement.setAttribute('role', 'button');\n      }\n    }\n    /** Sets thte `type` attribute of the trigger. */\n\n\n    _setType() {\n      const element = this._elementRef.nativeElement;\n\n      if (element.nodeName === 'BUTTON' && !element.getAttribute('type')) {\n        // Prevents form submissions.\n        element.setAttribute('type', 'button');\n      }\n    }\n\n  }\n\n  CdkMenuTrigger.ɵfac = function CdkMenuTrigger_Factory(t) {\n    return new (t || CdkMenuTrigger)();\n  };\n\n  CdkMenuTrigger.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CdkMenuTrigger,\n    selectors: [[\"\", \"cdkMenuTriggerFor\", \"\"]],\n    hostAttrs: [\"aria-haspopup\", \"menu\", 1, \"cdk-menu-trigger\"],\n    hostVars: 1,\n    hostBindings: function CdkMenuTrigger_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"focusin\", function CdkMenuTrigger_focusin_HostBindingHandler() {\n          return ctx._setHasFocus(true);\n        })(\"focusout\", function CdkMenuTrigger_focusout_HostBindingHandler() {\n          return ctx._setHasFocus(false);\n        })(\"keydown\", function CdkMenuTrigger_keydown_HostBindingHandler($event) {\n          return ctx._toggleOnKeydown($event);\n        })(\"click\", function CdkMenuTrigger_click_HostBindingHandler() {\n          return ctx.toggle();\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-expanded\", ctx.isOpen());\n      }\n    },\n    inputs: {\n      menuTemplateRef: [\"cdkMenuTriggerFor\", \"menuTemplateRef\"],\n      menuPosition: [\"cdkMenuPosition\", \"menuPosition\"]\n    },\n    outputs: {\n      opened: \"cdkMenuOpened\",\n      closed: \"cdkMenuClosed\"\n    },\n    exportAs: [\"cdkMenuTriggerFor\"],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: MENU_TRIGGER,\n      useExisting: CdkMenuTrigger\n    }, PARENT_OR_NEW_MENU_STACK_PROVIDER]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return CdkMenuTrigger;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Directive which provides the ability for an element to be focused and navigated to using the\n * keyboard when residing in a CdkMenu, CdkMenuBar, or CdkMenuGroup. It performs user defined\n * behavior when clicked.\n */\n\n\nlet CdkMenuItem = /*#__PURE__*/(() => {\n  class CdkMenuItem {\n    constructor() {\n      /** The directionality (text direction) of the current page. */\n      this._dir = inject(Directionality, InjectFlags.Optional);\n      /** The menu's native DOM host element. */\n\n      this._elementRef = inject(ElementRef);\n      /** The Angular zone. */\n\n      this._ngZone = inject(NgZone);\n      /** The menu aim service used by this menu. */\n\n      this._menuAim = inject(MENU_AIM, InjectFlags.Optional);\n      /** The stack of menus this menu belongs to. */\n\n      this._menuStack = inject(MENU_STACK);\n      /** The parent menu in which this menuitem resides. */\n\n      this._parentMenu = inject(CDK_MENU, InjectFlags.Optional);\n      /** Reference to the CdkMenuItemTrigger directive if one is added to the same element */\n\n      this._menuTrigger = inject(CdkMenuTrigger, InjectFlags.Optional | InjectFlags.Self);\n      this._disabled = false;\n      /**\n       * If this MenuItem is a regular MenuItem, outputs when it is triggered by a keyboard or mouse\n       * event.\n       */\n\n      this.triggered = new EventEmitter();\n      /** Whether the menu item opens a menu. */\n\n      this.hasMenu = !!this._menuTrigger;\n      /**\n       * The tabindex for this menu item managed internally and used for implementing roving a\n       * tab index.\n       */\n\n      this._tabindex = -1;\n      /** Whether the item should close the menu if triggered by the spacebar. */\n\n      this.closeOnSpacebarTrigger = true;\n      /** Emits when the menu item is destroyed. */\n\n      this.destroyed = new Subject();\n\n      this._setupMouseEnter();\n\n      this._setType();\n\n      if (this._isStandaloneItem()) {\n        this._tabindex = 0;\n      }\n    }\n    /**  Whether the CdkMenuItem is disabled - defaults to false */\n\n\n    get disabled() {\n      return this._disabled;\n    }\n\n    set disabled(value) {\n      this._disabled = coerceBooleanProperty(value);\n    }\n\n    ngOnDestroy() {\n      this.destroyed.next();\n      this.destroyed.complete();\n    }\n    /** Place focus on the element. */\n\n\n    focus() {\n      this._elementRef.nativeElement.focus();\n    }\n    /**\n     * If the menu item is not disabled and the element does not have a menu trigger attached, emit\n     * on the cdkMenuItemTriggered emitter and close all open menus.\n     * @param options Options the configure how the item is triggered\n     *   - keepOpen: specifies that the menu should be kept open after triggering the item.\n     */\n\n\n    trigger(options) {\n      const {\n        keepOpen\n      } = { ...options\n      };\n\n      if (!this.disabled && !this.hasMenu) {\n        this.triggered.next();\n\n        if (!keepOpen) {\n          this._menuStack.closeAll({\n            focusParentTrigger: true\n          });\n        }\n      }\n    }\n    /** Return true if this MenuItem has an attached menu and it is open. */\n\n\n    isMenuOpen() {\n      return !!this._menuTrigger?.isOpen();\n    }\n    /**\n     * Get a reference to the rendered Menu if the Menu is open and it is visible in the DOM.\n     * @return the menu if it is open, otherwise undefined.\n     */\n\n\n    getMenu() {\n      return this._menuTrigger?.getMenu();\n    }\n    /** Get the CdkMenuTrigger associated with this element. */\n\n\n    getMenuTrigger() {\n      return this._menuTrigger;\n    }\n    /** Get the label for this element which is required by the FocusableOption interface. */\n\n\n    getLabel() {\n      return this.typeaheadLabel || this._elementRef.nativeElement.textContent?.trim() || '';\n    }\n    /** Reset the tabindex to -1. */\n\n\n    _resetTabIndex() {\n      if (!this._isStandaloneItem()) {\n        this._tabindex = -1;\n      }\n    }\n    /**\n     * Set the tab index to 0 if not disabled and it's a focus event, or a mouse enter if this element\n     * is not in a menu bar.\n     */\n\n\n    _setTabIndex(event) {\n      if (this.disabled) {\n        return;\n      } // don't set the tabindex if there are no open sibling or parent menus\n\n\n      if (!event || !this._menuStack.isEmpty()) {\n        this._tabindex = 0;\n      }\n    }\n    /**\n     * Handles keyboard events for the menu item, specifically either triggering the user defined\n     * callback or opening/closing the current menu based on whether the left or right arrow key was\n     * pressed.\n     * @param event the keyboard event to handle\n     */\n\n\n    _onKeydown(event) {\n      switch (event.keyCode) {\n        case SPACE:\n        case ENTER:\n          if (!hasModifierKey(event)) {\n            this.trigger({\n              keepOpen: event.keyCode === SPACE && !this.closeOnSpacebarTrigger\n            });\n          }\n\n          break;\n\n        case RIGHT_ARROW:\n          if (!hasModifierKey(event)) {\n            if (this._parentMenu && this._isParentVertical()) {\n              if (this._dir?.value !== 'rtl') {\n                this._forwardArrowPressed(event);\n              } else {\n                this._backArrowPressed(event);\n              }\n            }\n          }\n\n          break;\n\n        case LEFT_ARROW:\n          if (!hasModifierKey(event)) {\n            if (this._parentMenu && this._isParentVertical()) {\n              if (this._dir?.value !== 'rtl') {\n                this._backArrowPressed(event);\n              } else {\n                this._forwardArrowPressed(event);\n              }\n            }\n          }\n\n          break;\n      }\n    }\n    /** Whether this menu item is standalone or within a menu or menu bar. */\n\n\n    _isStandaloneItem() {\n      return !this._parentMenu;\n    }\n    /**\n     * Handles the user pressing the back arrow key.\n     * @param event The keyboard event.\n     */\n\n\n    _backArrowPressed(event) {\n      const parentMenu = this._parentMenu;\n\n      if (this._menuStack.hasInlineMenu() || this._menuStack.length() > 1) {\n        event.preventDefault();\n\n        this._menuStack.close(parentMenu, {\n          focusNextOnEmpty: this._menuStack.inlineMenuOrientation() === 'horizontal' ? 1\n          /* FocusNext.previousItem */\n          : 2\n          /* FocusNext.currentItem */\n          ,\n          focusParentTrigger: true\n        });\n      }\n    }\n    /**\n     * Handles the user pressing the forward arrow key.\n     * @param event The keyboard event.\n     */\n\n\n    _forwardArrowPressed(event) {\n      if (!this.hasMenu && this._menuStack.inlineMenuOrientation() === 'horizontal') {\n        event.preventDefault();\n\n        this._menuStack.closeAll({\n          focusNextOnEmpty: 0\n          /* FocusNext.nextItem */\n          ,\n          focusParentTrigger: true\n        });\n      }\n    }\n    /**\n     * Subscribe to the mouseenter events and close any sibling menu items if this element is moused\n     * into.\n     */\n\n\n    _setupMouseEnter() {\n      if (!this._isStandaloneItem()) {\n        const closeOpenSiblings = () => this._ngZone.run(() => this._menuStack.closeSubMenuOf(this._parentMenu));\n\n        this._ngZone.runOutsideAngular(() => fromEvent(this._elementRef.nativeElement, 'mouseenter').pipe(filter(() => !this._menuStack.isEmpty() && !this.hasMenu), takeUntil(this.destroyed)).subscribe(() => {\n          if (this._menuAim) {\n            this._menuAim.toggle(closeOpenSiblings);\n          } else {\n            closeOpenSiblings();\n          }\n        }));\n      }\n    }\n    /**\n     * Return true if the enclosing parent menu is configured in a horizontal orientation, false\n     * otherwise or if no parent.\n     */\n\n\n    _isParentVertical() {\n      return this._parentMenu?.orientation === 'vertical';\n    }\n    /** Sets the `type` attribute of the menu item. */\n\n\n    _setType() {\n      const element = this._elementRef.nativeElement;\n\n      if (element.nodeName === 'BUTTON' && !element.getAttribute('type')) {\n        // Prevent form submissions.\n        element.setAttribute('type', 'button');\n      }\n    }\n\n  }\n\n  CdkMenuItem.ɵfac = function CdkMenuItem_Factory(t) {\n    return new (t || CdkMenuItem)();\n  };\n\n  CdkMenuItem.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CdkMenuItem,\n    selectors: [[\"\", \"cdkMenuItem\", \"\"]],\n    hostAttrs: [\"role\", \"menuitem\", 1, \"cdk-menu-item\"],\n    hostVars: 2,\n    hostBindings: function CdkMenuItem_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"blur\", function CdkMenuItem_blur_HostBindingHandler() {\n          return ctx._resetTabIndex();\n        })(\"focus\", function CdkMenuItem_focus_HostBindingHandler() {\n          return ctx._setTabIndex();\n        })(\"click\", function CdkMenuItem_click_HostBindingHandler() {\n          return ctx.trigger();\n        })(\"keydown\", function CdkMenuItem_keydown_HostBindingHandler($event) {\n          return ctx._onKeydown($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵhostProperty(\"tabindex\", ctx._tabindex);\n        i0.ɵɵattribute(\"aria-disabled\", ctx.disabled || null);\n      }\n    },\n    inputs: {\n      disabled: [\"cdkMenuItemDisabled\", \"disabled\"],\n      typeaheadLabel: [\"cdkMenuitemTypeaheadLabel\", \"typeaheadLabel\"]\n    },\n    outputs: {\n      triggered: \"cdkMenuItemTriggered\"\n    },\n    exportAs: [\"cdkMenuItem\"]\n  });\n  return CdkMenuItem;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * PointerFocusTracker keeps track of the currently active item under mouse focus. It also has\n * observables which emit when the users mouse enters and leaves a tracked element.\n */\n\n\nclass PointerFocusTracker {\n  constructor(\n  /** The list of items being tracked. */\n  _items) {\n    this._items = _items;\n    /** Emits when an element is moused into. */\n\n    this.entered = this._getItemPointerEntries();\n    /** Emits when an element is moused out. */\n\n    this.exited = this._getItemPointerExits();\n    /** Emits when this is destroyed. */\n\n    this._destroyed = new Subject();\n    this.entered.subscribe(element => this.activeElement = element);\n    this.exited.subscribe(() => {\n      this.previousElement = this.activeElement;\n      this.activeElement = undefined;\n    });\n  }\n  /** Stop the managers listeners. */\n\n\n  destroy() {\n    this._destroyed.next();\n\n    this._destroyed.complete();\n  }\n  /**\n   * Gets a stream of pointer (mouse) entries into the given items.\n   * This should typically run outside the Angular zone.\n   */\n\n\n  _getItemPointerEntries() {\n    return defer(() => this._items.changes.pipe(startWith(this._items), mergeMap(list => list.map(element => fromEvent(element._elementRef.nativeElement, 'mouseenter').pipe(mapTo(element), takeUntil(this._items.changes)))), mergeAll()));\n  }\n  /**\n   * Gets a stream of pointer (mouse) exits out of the given items.\n   * This should typically run outside the Angular zone.\n   */\n\n\n  _getItemPointerExits() {\n    return defer(() => this._items.changes.pipe(startWith(this._items), mergeMap(list => list.map(element => fromEvent(element._elementRef.nativeElement, 'mouseout').pipe(mapTo(element), takeUntil(this._items.changes)))), mergeAll()));\n  }\n\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Counter used to create unique IDs for menus. */\n\n\nlet nextId$1 = 0;\n/**\n * Abstract directive that implements shared logic common to all menus.\n * This class can be extended to create custom menu types.\n */\n\nlet CdkMenuBase = /*#__PURE__*/(() => {\n  class CdkMenuBase extends CdkMenuGroup {\n    constructor() {\n      super(...arguments);\n      /** The menu's native DOM host element. */\n\n      this.nativeElement = inject(ElementRef).nativeElement;\n      /** The Angular zone. */\n\n      this.ngZone = inject(NgZone);\n      /** The stack of menus this menu belongs to. */\n\n      this.menuStack = inject(MENU_STACK);\n      /** The menu aim service used by this menu. */\n\n      this.menuAim = inject(MENU_AIM, InjectFlags.Optional | InjectFlags.Self);\n      /** The directionality (text direction) of the current page. */\n\n      this.dir = inject(Directionality, InjectFlags.Optional);\n      /** The id of the menu's host element. */\n\n      this.id = `cdk-menu-${nextId$1++}`;\n      /** The direction items in the menu flow. */\n\n      this.orientation = 'vertical';\n      /**\n       * Whether the menu is displayed inline (i.e. always present vs a conditional popup that the\n       * user triggers with a trigger element).\n       */\n\n      this.isInline = false;\n      /** Emits when the MenuBar is destroyed. */\n\n      this.destroyed = new Subject();\n      /** Whether this menu's menu stack has focus. */\n\n      this._menuStackHasFocus = false;\n    }\n\n    ngAfterContentInit() {\n      if (!this.isInline) {\n        this.menuStack.push(this);\n      }\n\n      this._setKeyManager();\n\n      this._subscribeToMenuStackHasFocus();\n\n      this._subscribeToMenuOpen();\n\n      this._subscribeToMenuStackClosed();\n\n      this._setUpPointerTracker();\n    }\n\n    ngOnDestroy() {\n      this.destroyed.next();\n      this.destroyed.complete();\n      this.pointerTracker?.destroy();\n    }\n    /**\n     * Place focus on the first MenuItem in the menu and set the focus origin.\n     * @param focusOrigin The origin input mode of the focus event.\n     */\n\n\n    focusFirstItem(focusOrigin = 'program') {\n      this.keyManager.setFocusOrigin(focusOrigin);\n      this.keyManager.setFirstItemActive();\n    }\n    /**\n     * Place focus on the last MenuItem in the menu and set the focus origin.\n     * @param focusOrigin The origin input mode of the focus event.\n     */\n\n\n    focusLastItem(focusOrigin = 'program') {\n      this.keyManager.setFocusOrigin(focusOrigin);\n      this.keyManager.setLastItemActive();\n    }\n    /** Gets the tabindex for this menu. */\n\n\n    _getTabIndex() {\n      const tabindexIfInline = this._menuStackHasFocus ? -1 : 0;\n      return this.isInline ? tabindexIfInline : null;\n    }\n    /**\n     * Close the open menu if the current active item opened the requested MenuStackItem.\n     * @param menu The menu requested to be closed.\n     * @param options Options to configure the behavior on close.\n     *   - `focusParentTrigger` Whether to focus the parent trigger after closing the menu.\n     */\n\n\n    closeOpenMenu(menu, options) {\n      const {\n        focusParentTrigger\n      } = { ...options\n      };\n      const keyManager = this.keyManager;\n      const trigger = this.triggerItem;\n\n      if (menu === trigger?.getMenuTrigger()?.getMenu()) {\n        trigger?.getMenuTrigger()?.close(); // If the user has moused over a sibling item we want to focus the element under mouse focus\n        // not the trigger which previously opened the now closed menu.\n\n        if (focusParentTrigger) {\n          if (trigger) {\n            keyManager.setActiveItem(trigger);\n          } else {\n            keyManager.setFirstItemActive();\n          }\n        }\n      }\n    }\n    /** Setup the FocusKeyManager with the correct orientation for the menu. */\n\n\n    _setKeyManager() {\n      this.keyManager = new FocusKeyManager(this.items).withWrap().withTypeAhead().withHomeAndEnd();\n\n      if (this.orientation === 'horizontal') {\n        this.keyManager.withHorizontalOrientation(this.dir?.value || 'ltr');\n      } else {\n        this.keyManager.withVerticalOrientation();\n      }\n    }\n    /**\n     * Subscribe to the menu trigger's open events in order to track the trigger which opened the menu\n     * and stop tracking it when the menu is closed.\n     */\n\n\n    _subscribeToMenuOpen() {\n      const exitCondition = merge(this.items.changes, this.destroyed);\n      this.items.changes.pipe(startWith(this.items), mergeMap(list => list.filter(item => item.hasMenu).map(item => item.getMenuTrigger().opened.pipe(mapTo(item), takeUntil(exitCondition)))), mergeAll(), switchMap(item => {\n        this.triggerItem = item;\n        return item.getMenuTrigger().closed;\n      }), takeUntil(this.destroyed)).subscribe(() => this.triggerItem = undefined);\n    }\n    /** Subscribe to the MenuStack close events. */\n\n\n    _subscribeToMenuStackClosed() {\n      this.menuStack.closed.pipe(takeUntil(this.destroyed)).subscribe(({\n        item,\n        focusParentTrigger\n      }) => this.closeOpenMenu(item, {\n        focusParentTrigger\n      }));\n    }\n    /** Subscribe to the MenuStack hasFocus events. */\n\n\n    _subscribeToMenuStackHasFocus() {\n      if (this.isInline) {\n        this.menuStack.hasFocus.pipe(takeUntil(this.destroyed)).subscribe(hasFocus => {\n          this._menuStackHasFocus = hasFocus;\n        });\n      }\n    }\n    /**\n     * Set the PointerFocusTracker and ensure that when mouse focus changes the key manager is updated\n     * with the latest menu item under mouse focus.\n     */\n\n\n    _setUpPointerTracker() {\n      if (this.menuAim) {\n        this.ngZone.runOutsideAngular(() => {\n          this.pointerTracker = new PointerFocusTracker(this.items);\n        });\n        this.menuAim.initialize(this, this.pointerTracker);\n      }\n    }\n\n  }\n\n  CdkMenuBase.ɵfac = /* @__PURE__ */function () {\n    let ɵCdkMenuBase_BaseFactory;\n    return function CdkMenuBase_Factory(t) {\n      return (ɵCdkMenuBase_BaseFactory || (ɵCdkMenuBase_BaseFactory = i0.ɵɵgetInheritedFactory(CdkMenuBase)))(t || CdkMenuBase);\n    };\n  }();\n\n  CdkMenuBase.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CdkMenuBase,\n    contentQueries: function CdkMenuBase_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, CdkMenuItem, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.items = _t);\n      }\n    },\n    hostAttrs: [\"role\", \"menu\"],\n    hostVars: 4,\n    hostBindings: function CdkMenuBase_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"focus\", function CdkMenuBase_focus_HostBindingHandler() {\n          return ctx.focusFirstItem();\n        })(\"focusin\", function CdkMenuBase_focusin_HostBindingHandler() {\n          return ctx.menuStack.setHasFocus(true);\n        })(\"focusout\", function CdkMenuBase_focusout_HostBindingHandler() {\n          return ctx.menuStack.setHasFocus(false);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵhostProperty(\"tabindex\", ctx._getTabIndex())(\"id\", ctx.id);\n        i0.ɵɵattribute(\"aria-orientation\", ctx.orientation)(\"data-cdk-menu-stack-id\", ctx.menuStack.id);\n      }\n    },\n    inputs: {\n      id: \"id\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return CdkMenuBase;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Directive which configures the element as a Menu which should contain child elements marked as\n * CdkMenuItem or CdkMenuGroup. Sets the appropriate role and aria-attributes for a menu and\n * contains accessible keyboard and mouse handling logic.\n *\n * It also acts as a RadioGroup for elements marked with role `menuitemradio`.\n */\n\n\nlet CdkMenu = /*#__PURE__*/(() => {\n  class CdkMenu extends CdkMenuBase {\n    constructor() {\n      super();\n      this._parentTrigger = inject(MENU_TRIGGER, InjectFlags.Optional);\n      /** Event emitted when the menu is closed. */\n\n      this.closed = new EventEmitter();\n      /** The direction items in the menu flow. */\n\n      this.orientation = 'vertical';\n      /** Whether the menu is displayed inline (i.e. always present vs a conditional popup that the user triggers with a trigger element). */\n\n      this.isInline = !this._parentTrigger;\n      this.destroyed.subscribe(this.closed);\n      this._parentTrigger?.registerChildMenu(this);\n    }\n\n    ngAfterContentInit() {\n      super.ngAfterContentInit();\n\n      this._subscribeToMenuStackEmptied();\n    }\n\n    ngOnDestroy() {\n      super.ngOnDestroy();\n      this.closed.complete();\n    }\n    /**\n     * Handle keyboard events for the Menu.\n     * @param event The keyboard event to be handled.\n     */\n\n\n    _handleKeyEvent(event) {\n      const keyManager = this.keyManager;\n\n      switch (event.keyCode) {\n        case LEFT_ARROW:\n        case RIGHT_ARROW:\n          if (!hasModifierKey(event)) {\n            event.preventDefault();\n            keyManager.setFocusOrigin('keyboard');\n            keyManager.onKeydown(event);\n          }\n\n          break;\n\n        case ESCAPE:\n          if (!hasModifierKey(event)) {\n            event.preventDefault();\n            this.menuStack.close(this, {\n              focusNextOnEmpty: 2\n              /* FocusNext.currentItem */\n              ,\n              focusParentTrigger: true\n            });\n          }\n\n          break;\n\n        case TAB:\n          if (!hasModifierKey(event, 'altKey', 'metaKey', 'ctrlKey')) {\n            this.menuStack.closeAll({\n              focusParentTrigger: true\n            });\n          }\n\n          break;\n\n        default:\n          keyManager.onKeydown(event);\n      }\n    }\n    /**\n     * Set focus the either the current, previous or next item based on the FocusNext event.\n     * @param focusNext The element to focus.\n     */\n\n\n    _toggleMenuFocus(focusNext) {\n      const keyManager = this.keyManager;\n\n      switch (focusNext) {\n        case 0\n        /* FocusNext.nextItem */\n        :\n          keyManager.setFocusOrigin('keyboard');\n          keyManager.setNextItemActive();\n          break;\n\n        case 1\n        /* FocusNext.previousItem */\n        :\n          keyManager.setFocusOrigin('keyboard');\n          keyManager.setPreviousItemActive();\n          break;\n\n        case 2\n        /* FocusNext.currentItem */\n        :\n          if (keyManager.activeItem) {\n            keyManager.setFocusOrigin('keyboard');\n            keyManager.setActiveItem(keyManager.activeItem);\n          }\n\n          break;\n      }\n    }\n    /** Subscribe to the MenuStack emptied events. */\n\n\n    _subscribeToMenuStackEmptied() {\n      this.menuStack.emptied.pipe(takeUntil(this.destroyed)).subscribe(event => this._toggleMenuFocus(event));\n    }\n\n  }\n\n  CdkMenu.ɵfac = function CdkMenu_Factory(t) {\n    return new (t || CdkMenu)();\n  };\n\n  CdkMenu.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CdkMenu,\n    selectors: [[\"\", \"cdkMenu\", \"\"]],\n    hostAttrs: [\"role\", \"menu\", 1, \"cdk-menu\"],\n    hostVars: 2,\n    hostBindings: function CdkMenu_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown\", function CdkMenu_keydown_HostBindingHandler($event) {\n          return ctx._handleKeyEvent($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"cdk-menu-inline\", ctx.isInline);\n      }\n    },\n    outputs: {\n      closed: \"closed\"\n    },\n    exportAs: [\"cdkMenu\"],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: CdkMenuGroup,\n      useExisting: CdkMenu\n    }, {\n      provide: CDK_MENU,\n      useExisting: CdkMenu\n    }, PARENT_OR_NEW_INLINE_MENU_STACK_PROVIDER('vertical')]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return CdkMenu;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Directive applied to an element which configures it as a MenuBar by setting the appropriate\n * role, aria attributes, and accessible keyboard and mouse handling logic. The component that\n * this directive is applied to should contain components marked with CdkMenuItem.\n *\n */\n\n\nlet CdkMenuBar = /*#__PURE__*/(() => {\n  class CdkMenuBar extends CdkMenuBase {\n    constructor() {\n      super(...arguments);\n      /** The direction items in the menu flow. */\n\n      this.orientation = 'horizontal';\n      /** Whether the menu is displayed inline (i.e. always present vs a conditional popup that the user triggers with a trigger element). */\n\n      this.isInline = true;\n    }\n\n    ngAfterContentInit() {\n      super.ngAfterContentInit();\n\n      this._subscribeToMenuStackEmptied();\n    }\n    /**\n     * Handle keyboard events for the Menu.\n     * @param event The keyboard event to be handled.\n     */\n\n\n    _handleKeyEvent(event) {\n      const keyManager = this.keyManager;\n\n      switch (event.keyCode) {\n        case UP_ARROW:\n        case DOWN_ARROW:\n        case LEFT_ARROW:\n        case RIGHT_ARROW:\n          if (!hasModifierKey(event)) {\n            const horizontalArrows = event.keyCode === LEFT_ARROW || event.keyCode === RIGHT_ARROW; // For a horizontal menu if the left/right keys were clicked, or a vertical menu if the\n            // up/down keys were clicked: if the current menu is open, close it then focus and open the\n            // next  menu.\n\n            if (horizontalArrows) {\n              event.preventDefault();\n              const prevIsOpen = keyManager.activeItem?.isMenuOpen();\n              keyManager.activeItem?.getMenuTrigger()?.close();\n              keyManager.setFocusOrigin('keyboard');\n              keyManager.onKeydown(event);\n\n              if (prevIsOpen) {\n                keyManager.activeItem?.getMenuTrigger()?.open();\n              }\n            }\n          }\n\n          break;\n\n        case ESCAPE:\n          if (!hasModifierKey(event)) {\n            event.preventDefault();\n            keyManager.activeItem?.getMenuTrigger()?.close();\n          }\n\n          break;\n\n        case TAB:\n          if (!hasModifierKey(event, 'altKey', 'metaKey', 'ctrlKey')) {\n            keyManager.activeItem?.getMenuTrigger()?.close();\n          }\n\n          break;\n\n        default:\n          keyManager.onKeydown(event);\n      }\n    }\n    /**\n     * Set focus to either the current, previous or next item based on the FocusNext event, then\n     * open the previous or next item.\n     * @param focusNext The element to focus.\n     */\n\n\n    _toggleOpenMenu(focusNext) {\n      const keyManager = this.keyManager;\n\n      switch (focusNext) {\n        case 0\n        /* FocusNext.nextItem */\n        :\n          keyManager.setFocusOrigin('keyboard');\n          keyManager.setNextItemActive();\n          keyManager.activeItem?.getMenuTrigger()?.open();\n          break;\n\n        case 1\n        /* FocusNext.previousItem */\n        :\n          keyManager.setFocusOrigin('keyboard');\n          keyManager.setPreviousItemActive();\n          keyManager.activeItem?.getMenuTrigger()?.open();\n          break;\n\n        case 2\n        /* FocusNext.currentItem */\n        :\n          if (keyManager.activeItem) {\n            keyManager.setFocusOrigin('keyboard');\n            keyManager.setActiveItem(keyManager.activeItem);\n          }\n\n          break;\n      }\n    }\n    /** Subscribe to the MenuStack emptied events. */\n\n\n    _subscribeToMenuStackEmptied() {\n      this.menuStack?.emptied.pipe(takeUntil(this.destroyed)).subscribe(event => this._toggleOpenMenu(event));\n    }\n\n  }\n\n  CdkMenuBar.ɵfac = /* @__PURE__ */function () {\n    let ɵCdkMenuBar_BaseFactory;\n    return function CdkMenuBar_Factory(t) {\n      return (ɵCdkMenuBar_BaseFactory || (ɵCdkMenuBar_BaseFactory = i0.ɵɵgetInheritedFactory(CdkMenuBar)))(t || CdkMenuBar);\n    };\n  }();\n\n  CdkMenuBar.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CdkMenuBar,\n    selectors: [[\"\", \"cdkMenuBar\", \"\"]],\n    hostAttrs: [\"role\", \"menubar\", 1, \"cdk-menu-bar\"],\n    hostBindings: function CdkMenuBar_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown\", function CdkMenuBar_keydown_HostBindingHandler($event) {\n          return ctx._handleKeyEvent($event);\n        });\n      }\n    },\n    exportAs: [\"cdkMenuBar\"],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: CdkMenuGroup,\n      useExisting: CdkMenuBar\n    }, {\n      provide: CDK_MENU,\n      useExisting: CdkMenuBar\n    }, {\n      provide: MENU_STACK,\n      useFactory: () => MenuStack.inline('horizontal')\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return CdkMenuBar;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Base class providing checked state for selectable MenuItems. */\n\n\nlet CdkMenuItemSelectable = /*#__PURE__*/(() => {\n  class CdkMenuItemSelectable extends CdkMenuItem {\n    constructor() {\n      super(...arguments);\n      this._checked = false;\n      /** Whether the item should close the menu if triggered by the spacebar. */\n\n      this.closeOnSpacebarTrigger = false;\n    }\n    /** Whether the element is checked */\n\n\n    get checked() {\n      return this._checked;\n    }\n\n    set checked(value) {\n      this._checked = coerceBooleanProperty(value);\n    }\n\n  }\n\n  CdkMenuItemSelectable.ɵfac = /* @__PURE__ */function () {\n    let ɵCdkMenuItemSelectable_BaseFactory;\n    return function CdkMenuItemSelectable_Factory(t) {\n      return (ɵCdkMenuItemSelectable_BaseFactory || (ɵCdkMenuItemSelectable_BaseFactory = i0.ɵɵgetInheritedFactory(CdkMenuItemSelectable)))(t || CdkMenuItemSelectable);\n    };\n  }();\n\n  CdkMenuItemSelectable.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CdkMenuItemSelectable,\n    hostVars: 2,\n    hostBindings: function CdkMenuItemSelectable_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-checked\", !!ctx.checked)(\"aria-disabled\", ctx.disabled || null);\n      }\n    },\n    inputs: {\n      checked: [\"cdkMenuItemChecked\", \"checked\"]\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return CdkMenuItemSelectable;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Counter used to set a unique id and name for a selectable item */\n\n\nlet nextId = 0;\n/**\n * A directive providing behavior for the \"menuitemradio\" ARIA role, which behaves similarly to\n * a conventional radio-button. Any sibling `CdkMenuItemRadio` instances within the same `CdkMenu`\n * or `CdkMenuGroup` comprise a radio group with unique selection enforced.\n */\n\nlet CdkMenuItemRadio = /*#__PURE__*/(() => {\n  class CdkMenuItemRadio extends CdkMenuItemSelectable {\n    constructor() {\n      super();\n      /** The unique selection dispatcher for this radio's `CdkMenuGroup`. */\n\n      this._selectionDispatcher = inject(UniqueSelectionDispatcher);\n      /** An ID to identify this radio item to the `UniqueSelectionDispatcher`. */\n\n      this._id = `${nextId++}`;\n\n      this._registerDispatcherListener();\n    }\n\n    ngOnDestroy() {\n      super.ngOnDestroy();\n\n      this._removeDispatcherListener();\n    }\n    /**\n     * Toggles the checked state of the radio-button.\n     * @param options Options the configure how the item is triggered\n     *   - keepOpen: specifies that the menu should be kept open after triggering the item.\n     */\n\n\n    trigger(options) {\n      super.trigger(options);\n\n      if (!this.disabled) {\n        this._selectionDispatcher.notify(this._id, '');\n      }\n    }\n    /** Configure the unique selection dispatcher listener in order to toggle the checked state  */\n\n\n    _registerDispatcherListener() {\n      this._removeDispatcherListener = this._selectionDispatcher.listen(id => {\n        this.checked = this._id === id;\n      });\n    }\n\n  }\n\n  CdkMenuItemRadio.ɵfac = function CdkMenuItemRadio_Factory(t) {\n    return new (t || CdkMenuItemRadio)();\n  };\n\n  CdkMenuItemRadio.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CdkMenuItemRadio,\n    selectors: [[\"\", \"cdkMenuItemRadio\", \"\"]],\n    hostAttrs: [\"role\", \"menuitemradio\"],\n    hostVars: 2,\n    hostBindings: function CdkMenuItemRadio_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"cdk-menu-item-radio\", true);\n      }\n    },\n    exportAs: [\"cdkMenuItemRadio\"],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: CdkMenuItemSelectable,\n      useExisting: CdkMenuItemRadio\n    }, {\n      provide: CdkMenuItem,\n      useExisting: CdkMenuItemSelectable\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return CdkMenuItemRadio;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * A directive providing behavior for the \"menuitemcheckbox\" ARIA role, which behaves similarly to a\n * conventional checkbox.\n */\n\n\nlet CdkMenuItemCheckbox = /*#__PURE__*/(() => {\n  class CdkMenuItemCheckbox extends CdkMenuItemSelectable {\n    /**\n     * Toggle the checked state of the checkbox.\n     * @param options Options the configure how the item is triggered\n     *   - keepOpen: specifies that the menu should be kept open after triggering the item.\n     */\n    trigger(options) {\n      super.trigger(options);\n\n      if (!this.disabled) {\n        this.checked = !this.checked;\n      }\n    }\n\n  }\n\n  CdkMenuItemCheckbox.ɵfac = /* @__PURE__ */function () {\n    let ɵCdkMenuItemCheckbox_BaseFactory;\n    return function CdkMenuItemCheckbox_Factory(t) {\n      return (ɵCdkMenuItemCheckbox_BaseFactory || (ɵCdkMenuItemCheckbox_BaseFactory = i0.ɵɵgetInheritedFactory(CdkMenuItemCheckbox)))(t || CdkMenuItemCheckbox);\n    };\n  }();\n\n  CdkMenuItemCheckbox.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CdkMenuItemCheckbox,\n    selectors: [[\"\", \"cdkMenuItemCheckbox\", \"\"]],\n    hostAttrs: [\"role\", \"menuitemcheckbox\"],\n    hostVars: 2,\n    hostBindings: function CdkMenuItemCheckbox_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"cdk-menu-item-checkbox\", true);\n      }\n    },\n    exportAs: [\"cdkMenuItemCheckbox\"],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: CdkMenuItemSelectable,\n      useExisting: CdkMenuItemCheckbox\n    }, {\n      provide: CdkMenuItem,\n      useExisting: CdkMenuItemSelectable\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return CdkMenuItemCheckbox;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** The preferred menu positions for the context menu. */\n\n\nconst CONTEXT_MENU_POSITIONS = /*#__PURE__*/STANDARD_DROPDOWN_BELOW_POSITIONS.map(position => {\n  // In cases where the first menu item in the context menu is a trigger the submenu opens on a\n  // hover event. We offset the context menu 2px by default to prevent this from occurring.\n  const offsetX = position.overlayX === 'start' ? 2 : -2;\n  const offsetY = position.overlayY === 'top' ? 2 : -2;\n  return { ...position,\n    offsetX,\n    offsetY\n  };\n});\n/** Tracks the last open context menu trigger across the entire application. */\n\nlet ContextMenuTracker = /*#__PURE__*/(() => {\n  class ContextMenuTracker {\n    /**\n     * Close the previous open context menu and set the given one as being open.\n     * @param trigger The trigger for the currently open Context Menu.\n     */\n    update(trigger) {\n      if (ContextMenuTracker._openContextMenuTrigger !== trigger) {\n        ContextMenuTracker._openContextMenuTrigger?.close();\n        ContextMenuTracker._openContextMenuTrigger = trigger;\n      }\n    }\n\n  }\n\n  ContextMenuTracker.ɵfac = function ContextMenuTracker_Factory(t) {\n    return new (t || ContextMenuTracker)();\n  };\n\n  ContextMenuTracker.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ContextMenuTracker,\n    factory: ContextMenuTracker.ɵfac,\n    providedIn: 'root'\n  });\n  return ContextMenuTracker;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A directive that opens a menu when a user right-clicks within its host element.\n * It is aware of nested context menus and will trigger only the lowest level non-disabled context menu.\n */\n\n\nlet CdkContextMenuTrigger = /*#__PURE__*/(() => {\n  class CdkContextMenuTrigger extends CdkMenuTriggerBase {\n    constructor() {\n      super();\n      /** The CDK overlay service. */\n\n      this._overlay = inject(Overlay);\n      /** The directionality of the page. */\n\n      this._directionality = inject(Directionality, InjectFlags.Optional);\n      /** The app's context menu tracking registry */\n\n      this._contextMenuTracker = inject(ContextMenuTracker);\n      this._disabled = false;\n\n      this._setMenuStackCloseListener();\n    }\n    /** Whether the context menu is disabled. */\n\n\n    get disabled() {\n      return this._disabled;\n    }\n\n    set disabled(value) {\n      this._disabled = coerceBooleanProperty(value);\n    }\n    /**\n     * Open the attached menu at the specified location.\n     * @param coordinates where to open the context menu\n     */\n\n\n    open(coordinates) {\n      this._open(coordinates, false);\n    }\n    /** Close the currently opened context menu. */\n\n\n    close() {\n      this.menuStack.closeAll();\n    }\n    /**\n     * Open the context menu and closes any previously open menus.\n     * @param event the mouse event which opens the context menu.\n     */\n\n\n    _openOnContextMenu(event) {\n      if (!this.disabled) {\n        // Prevent the native context menu from opening because we're opening a custom one.\n        event.preventDefault(); // Stop event propagation to ensure that only the closest enabled context menu opens.\n        // Otherwise, any context menus attached to containing elements would *also* open,\n        // resulting in multiple stacked context menus being displayed.\n\n        event.stopPropagation();\n\n        this._contextMenuTracker.update(this);\n\n        this._open({\n          x: event.clientX,\n          y: event.clientY\n        }, true); // A context menu can be triggered via a mouse right click or a keyboard shortcut.\n\n\n        if (event.button === 2) {\n          this.childMenu?.focusFirstItem('mouse');\n        } else if (event.button === 0) {\n          this.childMenu?.focusFirstItem('keyboard');\n        } else {\n          this.childMenu?.focusFirstItem('program');\n        }\n      }\n    }\n    /**\n     * Get the configuration object used to create the overlay.\n     * @param coordinates the location to place the opened menu\n     */\n\n\n    _getOverlayConfig(coordinates) {\n      return new OverlayConfig({\n        positionStrategy: this._getOverlayPositionStrategy(coordinates),\n        scrollStrategy: this._overlay.scrollStrategies.reposition(),\n        direction: this._directionality || undefined\n      });\n    }\n    /**\n     * Get the position strategy for the overlay which specifies where to place the menu.\n     * @param coordinates the location to place the opened menu\n     */\n\n\n    _getOverlayPositionStrategy(coordinates) {\n      return this._overlay.position().flexibleConnectedTo(coordinates).withLockedPosition().withGrowAfterOpen().withPositions(this.menuPosition ?? CONTEXT_MENU_POSITIONS);\n    }\n    /** Subscribe to the menu stack close events and close this menu when requested. */\n\n\n    _setMenuStackCloseListener() {\n      this.menuStack.closed.pipe(takeUntil(this.destroyed)).subscribe(({\n        item\n      }) => {\n        if (item === this.childMenu && this.isOpen()) {\n          this.closed.next();\n          this.overlayRef.detach();\n        }\n      });\n    }\n    /**\n     * Subscribe to the overlays outside pointer events stream and handle closing out the stack if a\n     * click occurs outside the menus.\n     * @param ignoreFirstAuxClick Whether to ignore the first auxclick event outside the menu.\n     */\n\n\n    _subscribeToOutsideClicks(ignoreFirstAuxClick) {\n      if (this.overlayRef) {\n        let outsideClicks = this.overlayRef.outsidePointerEvents(); // If the menu was triggered by the `contextmenu` event, skip the first `auxclick` event\n        // because it fires when the mouse is released on the same click that opened the menu.\n\n        if (ignoreFirstAuxClick) {\n          const [auxClicks, nonAuxClicks] = partition(outsideClicks, ({\n            type\n          }) => type === 'auxclick');\n          outsideClicks = merge(nonAuxClicks, auxClicks.pipe(skip(1)));\n        }\n\n        outsideClicks.pipe(takeUntil(this.stopOutsideClicksListener)).subscribe(event => {\n          if (!this.isElementInsideMenuStack(event.target)) {\n            this.menuStack.closeAll();\n          }\n        });\n      }\n    }\n    /**\n     * Open the attached menu at the specified location.\n     * @param coordinates where to open the context menu\n     * @param ignoreFirstOutsideAuxClick Whether to ignore the first auxclick outside the menu after opening.\n     */\n\n\n    _open(coordinates, ignoreFirstOutsideAuxClick) {\n      if (this.disabled) {\n        return;\n      }\n\n      if (this.isOpen()) {\n        // since we're moving this menu we need to close any submenus first otherwise they end up\n        // disconnected from this one.\n        this.menuStack.closeSubMenuOf(this.childMenu);\n        this.overlayRef.getConfig().positionStrategy.setOrigin(coordinates);\n        this.overlayRef.updatePosition();\n      } else {\n        this.opened.next();\n\n        if (this.overlayRef) {\n          this.overlayRef.getConfig().positionStrategy.setOrigin(coordinates);\n          this.overlayRef.updatePosition();\n        } else {\n          this.overlayRef = this._overlay.create(this._getOverlayConfig(coordinates));\n        }\n\n        this.overlayRef.attach(this.getMenuContentPortal());\n\n        this._subscribeToOutsideClicks(ignoreFirstOutsideAuxClick);\n      }\n    }\n\n  }\n\n  CdkContextMenuTrigger.ɵfac = function CdkContextMenuTrigger_Factory(t) {\n    return new (t || CdkContextMenuTrigger)();\n  };\n\n  CdkContextMenuTrigger.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CdkContextMenuTrigger,\n    selectors: [[\"\", \"cdkContextMenuTriggerFor\", \"\"]],\n    hostVars: 1,\n    hostBindings: function CdkContextMenuTrigger_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"contextmenu\", function CdkContextMenuTrigger_contextmenu_HostBindingHandler($event) {\n          return ctx._openOnContextMenu($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"data-cdk-menu-stack-id\", null);\n      }\n    },\n    inputs: {\n      menuTemplateRef: [\"cdkContextMenuTriggerFor\", \"menuTemplateRef\"],\n      menuPosition: [\"cdkContextMenuPosition\", \"menuPosition\"],\n      disabled: [\"cdkContextMenuDisabled\", \"disabled\"]\n    },\n    outputs: {\n      opened: \"cdkContextMenuOpened\",\n      closed: \"cdkContextMenuClosed\"\n    },\n    exportAs: [\"cdkContextMenuTriggerFor\"],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: MENU_TRIGGER,\n      useExisting: CdkContextMenuTrigger\n    }, {\n      provide: MENU_STACK,\n      useClass: MenuStack\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return CdkContextMenuTrigger;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** The list of components and directives that should be declared and exported from this module. */\n\n\nconst EXPORTED_DECLARATIONS = [CdkMenuBar, CdkMenu, CdkMenuItem, CdkMenuItemRadio, CdkMenuItemCheckbox, CdkMenuTrigger, CdkMenuGroup, CdkContextMenuTrigger, CdkTargetMenuAim];\n/** Module that declares components and directives for the CDK menu. */\n\nlet CdkMenuModule = /*#__PURE__*/(() => {\n  class CdkMenuModule {}\n\n  CdkMenuModule.ɵfac = function CdkMenuModule_Factory(t) {\n    return new (t || CdkMenuModule)();\n  };\n\n  CdkMenuModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: CdkMenuModule\n  });\n  CdkMenuModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [OverlayModule]\n  });\n  return CdkMenuModule;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { CDK_MENU, CdkContextMenuTrigger, CdkMenu, CdkMenuBar, CdkMenuBase, CdkMenuGroup, CdkMenuItem, CdkMenuItemCheckbox, CdkMenuItemRadio, CdkMenuItemSelectable, CdkMenuModule, CdkMenuTrigger, CdkMenuTriggerBase, CdkTargetMenuAim, ContextMenuTracker, MENU_AIM, MENU_STACK, MENU_TRIGGER, MenuStack, PARENT_OR_NEW_INLINE_MENU_STACK_PROVIDER, PARENT_OR_NEW_MENU_STACK_PROVIDER, PointerFocusTracker, TargetMenuAim }; //# sourceMappingURL=menu.mjs.map","map":null,"metadata":{},"sourceType":"module"}